package jmsgw_auth_demo.hooks;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.lightstreamer.jms_gateway.hooks.HookException;
import com.lightstreamer.jms_gateway.hooks.JmsGatewayHook;

public class AuthHook extends JmsGatewayHook {
    
    // List of connection ID-user pairs.
    private final ConcurrentHashMap<String, String> connectionIdToUser= new ConcurrentHashMap<String,String>();

    @Override
    @SuppressWarnings("rawtypes") 
    public boolean onConnectionRequest(String connectionId, String user, String password, Map clientContext, String clientPrincipal) throws HookException {

        /*
         * A user is connecting. We suppose the password works as an authentication token,
         * generated by the webserver in response to a user/password login made by the client.
         * Thus, we have to ask the same server (or a common backend like a memcached or a DB) if 
         * the received token is (still) valid. 
         * This demo does not actually perform the request, user/token pairs are hardcoded in the
         * AuthorizationRequest class 
         */
        AuthorizationResult result= AuthorizationRequest.validateToken(user, password);
        if (result != AuthorizationResult.OK)
            throw new HookException("Unauthorized access: token invalid for user '" + user + "'", result.toString());
        
        /*
         * Since subsequent hook calls will rely only on the connection ID, we store the user
         * associated with this connection ID on an internal map.
         */
        connectionIdToUser.put(connectionId, user);
        return true;

        /*
         * NOTE: as documented in the Lightstreamer JMS Gateway Documentation PDF, the onConnectionRequest
         * call is made during the notifyNewSession call of the JMS Gateway Metadata Adapter. For this
         * reason, if we have to block in order to perform the lookup for the client, a specific "SET"
         * thread pool may be configured in the adapters.xml configuration file for the JMS Gateway
         * Adapter Set. We could also speed up things using a local cache.
         */
        
        /*
         * NOTE 2: it is common practice for a webserver to place its session token inside a cookie;
         * if the cookie, the JS client library, and the Lightstreamer server are properly configured,
         * such cookie is available in the HTTP headers map, which can be obtained from the
         * clientContext map with the "HTTP_HEADERS" key; you might be tempted to use it to authenticate
         * the user: this approach is discouraged, please check the Server configuration for the 
         * <use_protected_js> and <forward_cookies> documentation for further info about the topic.
         */
    }
    
    @Override
    public void onConnectionClose(String connectionId) {
        
        /*
         * A user is disconnecting. We clear the internal map from the
         * association between this connection ID and its user.
         */
        connectionIdToUser.remove(connectionId);
    }
    
    @Override
    public boolean onMessageConsumerRequest(String connectionId, String dataAdapterName, String sessionGuid, String destinationName, boolean destinationIsTopic) throws HookException {
        
        /*
         * A user is trying to create a message consumer on a destination, we have to verify if 
         * he is authorized to see what he's asking for. To do this we first recover the user associated
         * with the connection ID from our internal map. 
         * This task might be performed by checking an external service or a local cache. If a service 
         * has to be queried, it is, in most cases, better to query it beforehand in the onConnectionRequest 
         * method. This class assumes such info has been cached somewhere else. On the other hand, the 
         * AuthHookWithAuthCache class (available in this package) takes a step further and shows 
         * the cache-during-onConnectionRequest approach. 
         * In any case this demo does not actually perform the request, as user authorizations 
         * are hardcoded in the AuthorizationRequest class.
         */
        String user= connectionIdToUser.get(connectionId);
        if (user == null)
            return false; // Should never happen
        
        AuthorizationResult result= AuthorizationRequest.authorizeDestination(user, destinationName);
        if (result != AuthorizationResult.OK)
            throw new HookException("Unauthorized access: user '" + user + "' can't receive messages from destination '" + destinationName + "'", result.toString());

        return true;
    }
    
    @Override
    public boolean onDurableSubscriptionRequest(String connectionId, String dataAdapterName, String clientId, String sessionGuid, String subscriptionName, String topicName) throws HookException {

        /*
         * A user is trying to create a durable subscription on a destination, we have to verify if 
         * he is authorized to see what he's asking for. To do this we first recover the user associated
         * with the connection ID from our internal map. 
         * This task might be performed by checking an external service or a local cache. If a service 
         * has to be queried, it is, in most cases, better to query it beforehand in the onConnectionRequest 
         * method. This class assumes such info has been cached somewhere else. On the other hand, the 
         * AuthHookWithAuthCache class (available in this package) takes a step further and shows 
         * the cache-during-onConnectionRequest approach. 
         * In any case this demo does not actually perform the request, as user authorizations 
         * are hardcoded in the AuthorizationRequest class.
         */
        String user= connectionIdToUser.get(connectionId);
        if (user == null)
            return false; // Should never happen
        
        AuthorizationResult result= AuthorizationRequest.authorizeDestination(user, topicName);
        if (result != AuthorizationResult.OK)
            throw new HookException("Unauthorized access: user '" + user + "' can't subscribe to topic '" + topicName + "'", result.toString());

        return true;
    }
    
    @Override
    public boolean onMessageProducerRequest(String connectionId, String dataAdapterName, String sessionGuid, String destinationName, boolean destinationIsTopic) throws HookException {

        /*
         * A user is trying to create a message producer on a destination, we have to verify if 
         * he is authorized to see what he's asking for. To do this we first recover the user associated
         * with the connection ID from our internal map. 
         * This task might be performed by checking an external service or a local cache. If a service 
         * has to be queried, it is, in most cases, better to query it beforehand in the onConnectionRequest 
         * method. This class assumes such info has been cached somewhere else. On the other hand, the 
         * AuthHookWithAuthCache class (available in this package) takes a step further and shows 
         * the cache-during-onConnectionRequest approach. 
         * In any case this demo does not actually perform the request, as user authorizations 
         * are hardcoded in the AuthorizationRequest class.
         */
        String user= connectionIdToUser.get(connectionId);
        if (user == null)
            return false; // Should never happen
        
        AuthorizationResult result= AuthorizationRequest.authorizeDestination(user, destinationName);
        if (result != AuthorizationResult.OK)
            throw new HookException("Unauthorized access: user '" + user + "' can't send messages to destination '" + destinationName + "'", result.toString());

        return true;
    }
}
